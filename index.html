<!doctype html>
<html lang="pl">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>made by piotrek &lt;3</title>

<style>
:root{
  --bg:#f6f7fb;--card:#fff;--text:#111;
  --cell:#eef2ff;--cell-sel:#b6ccff;--cell-found:#9fe6a0;
  --tile:46px
}
body.dark{
  --bg:#0f1220;--card:#1a1e35;--text:#f2f4ff;
  --cell:#2a2f55;--cell-sel:#3c4aa8;--cell-found:#2f8f5b;
}
body{font-family:system-ui;background:var(--bg);color:var(--text);padding:20px;transition:.3s}
.layout{display:grid;grid-template-columns:1fr 2fr 1fr;gap:14px}
.card{background:var(--card);border-radius:16px;padding:16px;box-shadow:0 10px 25px rgba(0,0,0,.15)}
.controls{display:flex;gap:8px;flex-wrap:wrap;margin-bottom:12px}
button,input,select{padding:10px;border-radius:10px;border:1px solid #ccc}
button{background:#4f7cff;color:#fff;border:none;cursor:pointer}
button.secondary{background:#777}
button.hidden{display:none}
button:disabled{opacity:0.5;cursor:not-allowed}

.board{display:grid;gap:6px;justify-content:center;min-height:200px}
.cell{
  width:var(--tile);height:var(--tile);
  display:flex;align-items:center;justify-content:center;
  font-weight:700;border-radius:10px;
  background:var(--cell);user-select:none;
  transition:.2s;
  opacity:0;
}
.cell.sel{background:var(--cell-sel)}
.cell.found{background:var(--cell-found)}
.cell.show {
  opacity: 1;
  transition: opacity 0.2s;
}
.cell.morph{animation:morph .4s ease forwards}
.cell.pulse{animation:pulse 1s infinite}

@keyframes morph{
  0%{transform:scale(.7);filter:hue-rotate(0deg);opacity:0}
  50%{transform:scale(1.15);filter:hue-rotate(180deg);opacity:1}
  100%{transform:scale(1);filter:hue-rotate(360deg);opacity:1}
}
@keyframes pulse{
  0%{transform:scale(1)}
  50%{transform:scale(1.15)}
  100%{transform:scale(1)}
}

.table table{width:100%;border-collapse:collapse}
.table th,.table td{padding:6px;border-bottom:1px solid #555;font-size:13px}

/* Style dla ranking√≥w */
.ranking-header {
  text-align: center;
  font-weight: bold;
  padding: 10px;
  border-radius: 8px;
  margin: 10px 0 5px 0;
  font-size: 0.9rem;
}

.global-header {
  background: linear-gradient(45deg, #4CAF50, #45a049);
  color: white;
}

.local-header {
  background: linear-gradient(45deg, #FF9800, #f57c00);
  color: white;
}

.ranking-divider {
  height: 20px;
  text-align: center;
  color: #666;
  font-size: 0.8rem;
  padding: 5px;
}

.ranking-container {
  max-height: 400px;
  overflow-y: auto;
}

.ranking-container::-webkit-scrollbar {
  width: 6px;
}

.ranking-container::-webkit-scrollbar-track {
  background: #f1f1f1;
  border-radius: 3px;
}

.ranking-container::-webkit-scrollbar-thumb {
  background: #888;
  border-radius: 3px;
}

.ranking-container::-webkit-scrollbar-thumb:hover {
  background: #555;
}

body.dark .ranking-container::-webkit-scrollbar-track {
  background: #2a2f55;
}

body.dark .ranking-container::-webkit-scrollbar-thumb {
  background: #4a4f75;
}

.celebration {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  pointer-events: none;
  z-index: 1000;
  display: none;
}

.cat-emoji {
  position: absolute;
  font-size: 2.5rem;
  animation: float 3s ease-in-out forwards;
  opacity: 0;
}

@keyframes float {
  0% {
    transform: translateY(100vh) rotate(0deg);
    opacity: 1;
  }
  50% {
    opacity: 1;
  }
  100% {
    transform: translateY(-100px) rotate(360deg);
    opacity: 0;
  }
}

.record-message {
  background: linear-gradient(45deg, #ff6b6b, #4ecdc4, #45b7d1);
  color: white;
  padding: 15px 25px;
  border-radius: 15px;
  font-weight: bold;
  font-size: 1.2rem;
  text-align: center;
  margin-top: 15px;
  animation: rainbow 2s infinite;
  display: none;
}

.cooldown-timer {
  color: #ff6b6b;
  font-weight: bold;
  font-size: 0.9rem;
  margin-top: 8px;
  text-align: center;
  display: none;
}

@keyframes rainbow {
  0% { background-position: 0% 50%; }
  50% { background-position: 100% 50%; }
  100% { background-position: 0% 50%; }
}

@media(max-width:900px){.layout{grid-template-columns:1fr}}

/* Mobile optimizations */
@media (max-width: 768px) {
  body {
    padding: 10px;
    font-size: 14px;
  }
  
  .card {
    padding: 12px;
  }
  
  h1 {
    font-size: 1.8rem;
    text-align: center;
  }
  
  .controls {
    flex-direction: column;
    align-items: stretch;
  }
  
  .controls button, 
  .controls input, 
  .controls select {
    width: 100%;
    margin-bottom: 8px;
    font-size: 1rem;
  }
  
  .layout {
    gap: 10px;
  }
  
  .cell {
    font-size: 0.9rem;
  }
  
  .table th, .table td {
    padding: 8px 4px;
    font-size: 12px;
  }
  
  .record-message {
    font-size: 1rem;
    padding: 12px 20px;
  }
  
  .cat-emoji {
    font-size: 2rem;
  }
  
  .ranking-header {
    font-size: 0.85rem;
    padding: 8px;
  }
}

@media (max-width: 480px) {
  :root {
    --tile: 36px;
  }
  
  body {
    padding: 8px;
  }
  
  .card {
    padding: 10px;
  }
  
  h1 {
    font-size: 1.6rem;
  }
  
  h3 {
    font-size: 1.1rem;
  }
  
  .cell {
    font-size: 0.85rem;
  }
  
  .controls button, 
  .controls input, 
  .controls select {
    padding: 8px;
    font-size: 0.9rem;
  }
}

@media (max-width: 360px) {
  :root {
    --tile: 32px;
  }
  
  .cell {
    font-size: 0.8rem;
  }
  
  .table th, .table td {
    font-size: 11px;
    padding: 6px 3px;
  }
}

/* Zapobieganie zaznaczaniu tekstu na mobile */
.cell {
  -webkit-touch-callout: none;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}

/* Lepsze dotykowe feedback */
button:active, .cell:active {
  transform: scale(0.98);
  transition: transform 0.1s;
}

/* Zapobieganie zoom przy podw√≥jnym tap */
* {
  -webkit-tap-highlight-color: transparent;
}
</style>
</head>

<body>
<h1>spoko giera</h1>

<div class="card controls">
  <input id="nick" placeholder="Tw√≥j nick">
  <select id="level">
    <option value="7">7√ó7</option>
    <option value="12">12√ó12</option>
    <option value="15">15√ó15</option>
  </select>
  <button id="start">Rozpocznij</button>
  <button id="giveup" class="secondary hidden">Poddaj siƒô</button>
  <button id="theme" class="secondary">üåô</button>
  <div id="cooldownTimer" class="cooldown-timer"></div>
</div>

<div class="layout">
  <div class="card">
    <h3>üìú Zasady</h3>
    <ul>
      <li>Ukryte Nazwisko</li>
      <li>Poziom / pion / przekƒÖtna</li>
      <li>S≈Çowo mo≈ºe byƒá wspak</li>
    </ul>
    <div id="hardestWord" style="margin-top: 20px; padding-top: 15px; border-top: 1px solid #eee;">
      <h4>üèÜ Najtrudniejsze s≈Çowo</h4>
      <div id="hardestWordDisplay" style="font-size: 1.1rem; font-weight: bold; color: #ff6b6b; margin-top: 10px;">
        ≈Åadujƒô...
      </div>
    </div>
  </div>

  <div class="card">
    <div id="board" class="board"></div>
    <div id="status"></div>
    <div id="recordMessage" class="record-message"></div>
  </div>

  <div class="card table">
    <h3>üèÜ Ranking <span id="lvlLabel"></span></h3>
    <div class="ranking-container">
      <table id="scores">
        <tr><th>Nick</th><th>Czas (s)</th></tr>
      </table>
    </div>
  </div>
</div>

<div id="celebration" class="celebration"></div>



<script>
window.addEventListener('load', () => {
  const style = document.createElement('style');
  style.textContent = `
    .preload-animation {
      animation: morph .4s ease;
    }
  `;
  document.head.appendChild(style);
  
  setTimeout(() => {
    document.head.removeChild(style);
  }, 100);
});

const WORDS=["KOBYLNIK","RENZ","≈öLƒÑSKA","≈ÅATA","ƒÜWIK","GRYSA","MATYSIAK","SZCZEPANIAK","KABACI≈ÉSKA","GƒÑGA≈ÅA","GRAL","KOWALCZYK","ORWAT","AUGUSTYNIAK","WASILEWSKI","GELLERT","BADOWSKA","BALCEREK","RATAJCZAK","GNI≈ÅKA","TOMCZAK","SIEK","SZARZEWSKI","KOPYCHYN","O≈ªA≈ÉSKA"];
const LETTERS="AƒÑBCƒÜDEƒòFGHIJKL≈ÅMN≈ÉO√ìPRS≈öTUVWXYZ≈π≈ª";
const CAT_EMOJIS = ["üò∫", "üò∏", "üòπ", "üòª", "üòº", "üòΩ", "üôÄ", "üòø", "üòæ", "üê±"];

const JSONBIN_BIN_ID = "697bcee243b1c97be955c919";
const JSONBIN_STATS_BIN_ID = "697bd2b6d0ea881f40913cce";
const JSONBIN_API_KEY = "$2a$10$Poka03qXK.rnNNTaGYW/zOLzQlBUuKiGlPxjSxYaKCKc1AV6c04We";

const boardEl=document.getElementById('board');
const statusEl=document.getElementById('status');
const scoresEl=document.getElementById('scores');
const startBtn=document.getElementById('start');
const giveupBtn=document.getElementById('giveup');
const levelEl=document.getElementById('level');
const lvlLabel=document.getElementById('lvlLabel');
const nickInput=document.getElementById('nick');
const themeBtn=document.getElementById('theme');
const celebrationEl=document.getElementById('celebration');
const recordMessageEl=document.getElementById('recordMessage');
const hardestWordDisplay=document.getElementById('hardestWordDisplay');
const cooldownTimerEl=document.getElementById('cooldownTimer');

let isMobile = false;
let lastTouchEnd = 0;

let grid=[],size=7,target="",path=[],selecting=false,startTime=0;
let solution=[];
let gameActive=false;
let currentDirection=null;
let isGameStarting = false;
let giveupCooldown = 0;
let cooldownInterval = null;
let isMouseDown = false;

function checkIfMobile() {
  isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || 
             (window.innerWidth <= 768);
  if (isMobile) {
    document.body.classList.add('mobile');
  }
  return isMobile;
}

function preventDoubleTapZoom(e) {
  const now = Date.now();
  if (now - lastTouchEnd <= 300) {
    e.preventDefault();
  }
  lastTouchEnd = now;
}

if(!localStorage.getItem('giveupStats')) {
  const initialStats = {};
  WORDS.forEach(word => {
    initialStats[word] = 0;
  });
  localStorage.setItem('giveupStats', JSON.stringify(initialStats));
}

if(localStorage.theme==='dark')document.body.classList.add('dark');
themeBtn.onclick=()=>{
  document.body.classList.toggle('dark');
  localStorage.theme=document.body.classList.contains('dark')?'dark':'light';
  themeBtn.textContent=document.body.classList.contains('dark')?'‚òÄÔ∏è':'üåô';
};

startBtn.onclick=startGame;
levelEl.onchange=renderScores;

document.addEventListener('DOMContentLoaded', () => {
  checkIfMobile();
  
  document.addEventListener('touchstart', function(e) {
    if (e.touches.length > 1) {
      e.preventDefault();
    }
  }, { passive: false });
  
  document.addEventListener('touchend', preventDoubleTapZoom, false);
  
  document.addEventListener('mousedown', () => {
    if (!isMobile && gameActive) isMouseDown = true;
  });
  
  document.addEventListener('mouseup', () => {
    if (!isMobile && gameActive) {
      isMouseDown = false;
      if (selecting) {
        endSelection();
      }
    }
  });
  
  window.addEventListener('orientationchange', handleOrientationChange);
  window.addEventListener('resize', handleResize);
  adjustBoardForMobile();
});

function handleOrientationChange() {
  setTimeout(() => {
    adjustBoardForMobile();
    if (boardEl.children.length > 0) {
      recalculateBoard();
    }
  }, 300);
}

function handleResize() {
  checkIfMobile();
  adjustBoardForMobile();
}

function adjustBoardForMobile() {
  if (isMobile) {
    const viewportWidth = window.innerWidth;
    let tileSize;
    if (viewportWidth < 400) {
      tileSize = 32;
    } else if (viewportWidth < 600) {
      tileSize = 36;
    } else if (viewportWidth < 768) {
      tileSize = 40;
    } else {
      tileSize = 46;
    }
    
    document.documentElement.style.setProperty('--tile', `${tileSize}px`);
    document.body.style.padding = '10px';
    statusEl.style.fontSize = '1rem';
    
    if (viewportWidth < 350) {
      document.querySelector('.controls').style.flexWrap = 'wrap';
      document.querySelectorAll('button, input, select').forEach(el => {
        el.style.padding = '8px';
        el.style.fontSize = '0.9rem';
      });
    }
  }
}

function recalculateBoard() {
  if (gameActive && boardEl.children.length > 0) {
  }
}

function startGame() {
  if (isGameStarting) return;
  isGameStarting = true;
  
  if(!nickInput.value.trim()) {
    alert("Podaj nick");
    isGameStarting = false;
    return;
  }
  
  if (isMobile && document.activeElement === nickInput) {
    nickInput.blur();
  }
  
  size=+levelEl.value;
  lvlLabel.textContent=size+"√ó"+size;

  startBtn.classList.add('hidden');
  giveupBtn.classList.remove('hidden');
  gameActive=true;
  currentDirection=null;
  recordMessageEl.style.display = 'none';
  
  giveupCooldown = 5;
  giveupBtn.disabled = true;
  giveupBtn.textContent = isMobile ? `Poddaj (${giveupCooldown}s)` : `Poddaj siƒô (${giveupCooldown}s)`;
  cooldownTimerEl.style.display = 'block';
  cooldownTimerEl.textContent = `Mo≈ºesz siƒô poddaƒá za: ${giveupCooldown}s`;
  
  if(cooldownInterval) clearInterval(cooldownInterval);
  cooldownInterval = setInterval(() => {
    giveupCooldown--;
    giveupBtn.textContent = isMobile ? `Poddaj (${giveupCooldown}s)` : `Poddaj siƒô (${giveupCooldown}s)`;
    cooldownTimerEl.textContent = `Mo≈ºesz siƒô poddaƒá za: ${giveupCooldown}s`;
    
    if(giveupCooldown <= 0) {
      clearInterval(cooldownInterval);
      cooldownInterval = null;
      giveupBtn.disabled = false;
      giveupBtn.textContent = isMobile ? "Poddaj" : "Poddaj siƒô";
      cooldownTimerEl.style.display = 'none';
    }
  }, 1000);

  prepareNewGrid();
  boardEl.innerHTML = '';
  draw();
  
  setTimeout(() => {
    animateBoardStart();
    startTime = Date.now();
    statusEl.textContent = "Znajd≈∫ ukryte s≈Çowo!";
    isGameStarting = false;
    
    if (isMobile) {
      setTimeout(() => {
        statusEl.innerHTML = "Znajd≈∫ ukryte s≈Çowo!<br><small style='color:#666;font-size:0.8rem'>PrzeciƒÖgnij palcem aby zaznaczyƒá</small>";
      }, 1500);
    }
  }, isMobile ? 100 : 50);
}

function animateBoardStart() {
  const cells = boardEl.children;
  if (cells.length === 0) return;
  
  const step = isMobile ? 60 : 40;
  const centerX = Math.floor(size / 2);
  const centerY = Math.floor(size / 2);
  
  for (let i = 0; i < cells.length; i++) {
    const cell = cells[i];
    const r = +cell.dataset.r;
    const c = +cell.dataset.c;
    
    const distance = Math.sqrt(Math.pow(r - centerY, 2) + Math.pow(c - centerX, 2));
    const delay = distance * step;
    
    setTimeout(() => {
      cell.classList.add('morph');
      cell.classList.add('show');
      
      const timeoutId = setTimeout(() => {
        cell.classList.remove('morph');
      }, 500);
      
      cell.addEventListener('animationend', function handler() {
        clearTimeout(timeoutId);
        cell.classList.remove('morph');
        cell.removeEventListener('animationend', handler);
      }, { once: true });
      
    }, delay);
  }
}

function prepareNewGrid(){
  grid=[...Array(size)].map(()=>Array(size).fill(''));
  
  let placed = false;
  let attempts = 0;
  const maxAttempts = 50;
  
  while (!placed && attempts < maxAttempts) {
    target=WORDS[Math.floor(Math.random()*WORDS.length)];
    
    if (target.length > size) {
      attempts++;
      continue;
    }
    
    solution=[];
    placed = placeWord();
    attempts++;
  }
  
  if (!placed) {
    const shortWords = WORDS.filter(word => word.length <= size);
    if (shortWords.length > 0) {
      target = shortWords[Math.floor(Math.random() * shortWords.length)];
      solution = [];
      placeWord();
    } else {
      target = WORDS[0].substring(0, size);
      solution = [];
      placeWord();
    }
  }
  
  fill();
}

function placeWord(){
  const dirs=[[1,0],[0,1],[1,1],[-1,0],[0,-1],[-1,-1],[1,-1],[-1,1]];
  const [dx,dy]=dirs[Math.floor(Math.random()*dirs.length)];
  const w=Math.random()<.5?target:[...target].reverse().join('');
  
  let maxR, maxC, minR, minC;
  
  if (dy > 0) {
    minR = 0;
    maxR = size - w.length;
  } else if (dy < 0) {
    minR = w.length - 1;
    maxR = size - 1;
  } else {
    minR = 0;
    maxR = size - 1;
  }
  
  if (dx > 0) {
    minC = 0;
    maxC = size - w.length;
  } else if (dx < 0) {
    minC = w.length - 1;
    maxC = size - 1;
  } else {
    minC = 0;
    maxC = size - 1;
  }
  
  if (minR > maxR || minC > maxC) {
    return false;
  }
  
  let r,c;
  r = minR + Math.floor(Math.random() * (maxR - minR + 1));
  c = minC + Math.floor(Math.random() * (maxC - minC + 1));
  
  for(let i=0;i<w.length;i++){
    const rr=r+dy*i;
    const cc=c+dx*i;
    if (rr >= 0 && rr < size && cc >= 0 && cc < size) {
      grid[rr][cc]=w[i];
      solution.push([rr,cc]);
    } else {
      return false;
    }
  }
  return true;
}

function fill(){
  for(let r=0;r<size;r++){
    for(let c=0;c<size;c++){
      if(!grid[r][c]){
        grid[r][c]=LETTERS[rand(LETTERS.length)];
      }
    }
  }
}

function draw() {
  boardEl.style.gridTemplateColumns = `repeat(${size}, var(--tile))`;
  boardEl.innerHTML = '';
  
  for (let r = 0; r < size; r++) {
    for (let c = 0; c < size; c++) {
      const cell = document.createElement('div');
      cell.className = 'cell';
      cell.dataset.r = r;
      cell.dataset.c = c;
      cell.textContent = grid[r][c];
      
      cell.style.touchAction = 'none';
      
      if (isMobile) {
        cell.addEventListener('touchstart', handleTouchStart, { passive: false });
        cell.addEventListener('touchmove', handleTouchMove, { passive: false });
        cell.addEventListener('touchend', handleTouchEnd);
      } else {
        cell.addEventListener('mousedown', handleMouseDown);
        cell.addEventListener('mouseenter', handleMouseEnter);
        cell.addEventListener('mouseup', handleMouseUp);
      }
      
      boardEl.appendChild(cell);
    }
  }
  
  if (isMobile) {
    document.addEventListener('touchend', handleGlobalTouchEnd);
  }
}

let touchStartCell = null;

function handleTouchStart(e) {
  if(!gameActive || this.classList.contains('found')) return;
  e.preventDefault();
  selecting = true;
  touchStartCell = this;
  path = [this];
  currentDirection = null;
  this.classList.add('sel');
}

function handleTouchMove(e) {
  if(!selecting || !gameActive) return;
  e.preventDefault();
  
  const touch = e.touches[0];
  const element = document.elementFromPoint(touch.clientX, touch.clientY);
  
  if(element && element.classList.contains('cell') && !element.classList.contains('found')) {
    if(path.includes(element)) return;
    
    const last = path[path.length-1];
    const dr = +element.dataset.r - +last.dataset.r;
    const dc = +element.dataset.c - +last.dataset.c;
    
    if(Math.abs(dr) > 1 || Math.abs(dc) > 1) return;
    if(dr !== 0 && dc !== 0 && Math.abs(dr) !== Math.abs(dc)) return;
    
    if(path.length === 1) {
      if(dr === 0 && dc !== 0) currentDirection = 'horizontal';
      else if(dc === 0 && dr !== 0) currentDirection = 'vertical';
      else if(Math.abs(dr) === Math.abs(dc)) currentDirection = 'diagonal';
    } else {
      const first = path[0];
      const second = path[1];
      const firstDr = +second.dataset.r - +first.dataset.r;
      const firstDc = +second.dataset.c - +first.dataset.c;
      
      if(firstDr === 0) {
        if(dr !== 0) return;
      } else if(firstDc === 0) {
        if(dc !== 0) return;
      } else {
        if(Math.abs(dr) !== Math.abs(dc)) return;
        if(Math.sign(dr) !== Math.sign(firstDr) || Math.sign(dc) !== Math.sign(firstDc)) return;
      }
    }
    
    path.push(element);
    element.classList.add('sel');
  }
}

function handleTouchEnd(e) {
  if(!selecting || !gameActive) return;
  selecting = false;
  
  const selectedWord = path.map(cell => cell.textContent).join('');
  const reversedWord = [...selectedWord].reverse().join('');
  
  if(selectedWord === target || reversedWord === target){
    path.forEach(cell => {
      cell.classList.remove('sel');
      cell.classList.add('found');
    });
    finish();
  } else {
    path.forEach(cell => cell.classList.remove('sel'));
  }
  
  path = [];
  currentDirection = null;
  touchStartCell = null;
}

function handleGlobalTouchEnd() {
  if (selecting) {
    handleTouchEnd();
  }
}

function handleMouseDown(e) {
  if(!gameActive || this.classList.contains('found')) return;
  e.preventDefault();
  selecting = true;
  isMouseDown = true;
  path = [this];
  currentDirection = null;
  this.classList.add('sel');
}

function handleMouseEnter() {
  if(!isMouseDown || !selecting || !gameActive || this.classList.contains('found')) return;
  if(path.includes(this)) return;
  
  const last = path[path.length-1];
  const dr = +this.dataset.r - +last.dataset.r;
  const dc = +this.dataset.c - +last.dataset.c;
  
  if(Math.abs(dr) > 1 || Math.abs(dc) > 1) return;
  if(dr !== 0 && dc !== 0 && Math.abs(dr) !== Math.abs(dc)) return;
  
  if(path.length === 1) {
    if(dr === 0 && dc !== 0) currentDirection = 'horizontal';
    else if(dc === 0 && dr !== 0) currentDirection = 'vertical';
    else if(Math.abs(dr) === Math.abs(dc)) currentDirection = 'diagonal';
  } else {
    const first = path[0];
    const second = path[1];
    const firstDr = +second.dataset.r - +first.dataset.r;
    const firstDc = +second.dataset.c - +first.dataset.c;
    
    if(firstDr === 0) {
      if(dr !== 0) return;
    } else if(firstDc === 0) {
      if(dc !== 0) return;
    } else {
      if(Math.abs(dr) !== Math.abs(dc)) return;
      if(Math.sign(dr) !== Math.sign(firstDr) || Math.sign(dc) !== Math.sign(firstDc)) return;
    }
  }
  
  path.push(this);
  this.classList.add('sel');
}

function handleMouseUp(e) {
  if(!selecting || !gameActive) return;
  isMouseDown = false;
  endSelection();
}

function endSelection() {
  selecting = false;
  
  const selectedWord = path.map(cell => cell.textContent).join('');
  const reversedWord = [...selectedWord].reverse().join('');
  
  if(selectedWord === target || reversedWord === target){
    path.forEach(cell => {
      cell.classList.remove('sel');
      cell.classList.add('found');
    });
    finish();
  } else {
    path.forEach(cell => {
      cell.classList.add('sel');
      setTimeout(() => {
        cell.classList.remove('sel');
      }, 300);
    });
  }
  
  path = [];
  currentDirection = null;
}

function finish(){
  gameActive = false;
  isMouseDown = false;
  const time = ((Date.now() - startTime) / 1000).toFixed(2);
  statusEl.textContent = `Gratulacje! Znaleziono s≈Çowo w ${time}s`;
  
  if(cooldownInterval) {
    clearInterval(cooldownInterval);
    cooldownInterval = null;
  }
  
  setTimeout(() => {
    addScore(nickInput.value.trim(), time);
  }, 0);
  
  startBtn.classList.remove('hidden');
  giveupBtn.classList.add('hidden');
}

giveupBtn.onclick = function() {
  if(giveupCooldown > 0 || !gameActive) return;
  
  gameActive = false;
  isMouseDown = false;
  
  const giveupStats = JSON.parse(localStorage.getItem('giveupStats'));
  giveupStats[target] = (giveupStats[target] || 0) + 1;
  localStorage.setItem('giveupStats', JSON.stringify(giveupStats));
  
  updateHardestWordDisplay();
  
  setTimeout(async () => {
    try {
      const response = await fetch(`https://api.jsonbin.io/v3/b/${JSONBIN_STATS_BIN_ID}/latest`, {
        headers: {
          'X-Master-Key': JSONBIN_API_KEY,
          'Content-Type': 'application/json'
        }
      });
      
      if (!response.ok) return;
      
      const data = await response.json();
      const globalStats = data.record || {};
      
      if (!globalStats[target]) {
        globalStats[target] = 1;
      } else {
        globalStats[target] += 1;
      }
      
      await fetch(`https://api.jsonbin.io/v3/b/${JSONBIN_STATS_BIN_ID}`, {
        method: 'PUT',
        headers: {
          'X-Master-Key': JSONBIN_API_KEY,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(globalStats)
      });
    } catch (error) {
      console.error("B≈ÇƒÖd zapisu statystyk:", error);
    }
  }, 0);
  
  const cells = [...boardEl.children];
  solution.forEach(([r,c], index) => {
    setTimeout(() => {
      const cell = cells.find(e => +e.dataset.r === r && +e.dataset.c === c);
      if(cell) {
        cell.classList.remove('sel');
        cell.classList.add('found', 'pulse');
      }
    }, index * 100);
  });
  
  statusEl.textContent = `S≈Çowo to: ${target}`;
  
  if(cooldownInterval) {
    clearInterval(cooldownInterval);
    cooldownInterval = null;
  }
  
  startBtn.classList.remove('hidden');
  giveupBtn.classList.add('hidden');
};

async function addScore(nick, time) {
  const currentSize = size;
  const key = 'scores_' + currentSize;
  let scores = JSON.parse(localStorage.getItem(key) || '[]');
  
  const normalizedNick = nick.toLowerCase().trim();
  
  scores = scores.filter(score => score.nick.toLowerCase().trim() !== normalizedNick);
  
  const oldBestTime = scores.length > 0 ? Math.min(...scores.map(s => s.time)) : Infinity;
  const isNewRecord = scores.length === 0 || +time < oldBestTime;
  
  scores.push({
    nick: nick.trim(),
    time: +time,
    date: new Date().toISOString()
  });
  
  scores.sort((a, b) => a.time - b.time);
  const topScores = scores.slice(0, 10);
  localStorage.setItem(key, JSON.stringify(topScores));
  
  try {
    const response = await fetch(`https://api.jsonbin.io/v3/b/${JSONBIN_BIN_ID}/latest`, {
      headers: {
        'X-Master-Key': JSONBIN_API_KEY,
        'Content-Type': 'application/json'
      }
    });
    
    if (response.ok) {
      const data = await response.json();
      const allScores = data.record || { "7": [], "12": [], "15": [] };
      
      if (!allScores[currentSize]) {
        allScores[currentSize] = [];
      }
      
      allScores[currentSize] = allScores[currentSize].filter(
        score => score.nick.toLowerCase().trim() !== normalizedNick
      );
      
      allScores[currentSize].push({
        nick: nick.trim(),
        time: +time,
        date: new Date().toISOString()
      });
      
      allScores[currentSize].sort((a, b) => a.time - b.time);
      allScores[currentSize] = allScores[currentSize].slice(0, 10);
      
      await fetch(`https://api.jsonbin.io/v3/b/${JSONBIN_BIN_ID}`, {
        method: 'PUT',
        headers: {
          'X-Master-Key': JSONBIN_API_KEY,
          'Content-Type': 'application/json',
          'X-Bin-Versioning': 'false'
        },
        body: JSON.stringify(allScores)
      });
      
      console.log("Wynik zsynchronizowany z serwerem");
    }
  } catch (error) {
    console.error("B≈ÇƒÖd synchronizacji z serwerem:", error);
  }
  
  renderScores();
  
  if(isNewRecord) {
    celebrateRecord(nick, time);
  }
}

function celebrateRecord(nick, time) {
  recordMessageEl.textContent = `üèÜ ${nick} ustanowi≈Çe≈õ rekord! ${time}s üèÜ`;
  recordMessageEl.style.display = 'block';
  
  celebrationEl.style.display = 'block';
  celebrationEl.innerHTML = '';
  
  const emojiCount = isMobile ? 10 : 20;
  
  for(let i = 0; i < emojiCount; i++) {
    const cat = document.createElement('div');
    cat.className = 'cat-emoji';
    cat.textContent = CAT_EMOJIS[Math.floor(Math.random() * CAT_EMOJIS.length)];
    
    const startX = Math.random() * window.innerWidth;
    cat.style.left = startX + 'px';
    
    const delay = Math.random() * 1000;
    cat.style.animationDelay = delay + 'ms';
    
    const duration = 2 + Math.random() * 2;
    cat.style.animationDuration = duration + 's';
    
    celebrationEl.appendChild(cat);
  }
  
  setTimeout(() => {
    celebrationEl.style.display = 'none';
    celebrationEl.innerHTML = '';
  }, 3000);
}

async function updateHardestWordDisplay() {
  const giveupStats = JSON.parse(localStorage.getItem('giveupStats'));
  const statsArray = Object.entries(giveupStats);
  
  if(statsArray.length > 0) {
    let hardestWord = '';
    let maxCount = 0;
    
    statsArray.forEach(([word, count]) => {
      if(count > maxCount) {
        maxCount = count;
        hardestWord = word;
      }
    });
    
    if(hardestWord && maxCount > 0) {
      hardestWordDisplay.innerHTML = `
        <div style="text-align: center;">
          <div style="font-size: 1.3rem; color: #ff6b6b;">${hardestWord}</div>
          <div style="font-size: 0.9rem; color: #666; margin-top: 5px;">
            Lokalnych podda≈Ñ: ${maxCount}
          </div>
        </div>
      `;
    } else {
      hardestWordDisplay.innerHTML = '<div style="color: #666; font-style: italic;">Brak danych</div>';
    }
  } else {
    hardestWordDisplay.innerHTML = '<div style="color: #666; font-style: italic;">Brak danych</div>';
  }
  
  setTimeout(async () => {
    try {
      const response = await fetch(`https://api.jsonbin.io/v3/b/${JSONBIN_STATS_BIN_ID}/latest`, {
        headers: {
          'X-Master-Key': JSONBIN_API_KEY
        }
      });
      
      if (!response.ok) return;
      
      const data = await response.json();
      const globalStats = data.record || {};
      
      let hardestWord = '';
      let maxCount = 0;
      
      Object.entries(globalStats).forEach(([word, count]) => {
        if (count > maxCount) {
          maxCount = count;
          hardestWord = word;
        }
      });
      
      if (hardestWord && maxCount > 0) {
        hardestWordDisplay.innerHTML = `
          <div style="text-align: center;">
            <div style="font-size: 1.3rem; color: #ff6b6b;">${hardestWord}</div>
            <div style="font-size: 0.9rem; color: #666; margin-top: 5px;">
              Globalnych podda≈Ñ: ${maxCount}
            </div>
            <div style="font-size: 0.7rem; color: #888; margin-top: 3px;">
              üü¢ Dane globalne
            </div>
          </div>
        `;
      }
    } catch (error) {
      console.error("B≈ÇƒÖd pobierania globalnych statystyk:", error);
    }
  }, 0);
}

// =============== NOWA FUNKCJA RENDEROWANIA WYNIK√ìW ===============
async function renderScores(){
  const selectedSize = levelEl.value;
  lvlLabel.textContent = selectedSize + "√ó" + selectedSize;
  
  scoresEl.innerHTML = '';
  
  let globalScores = [];
  let localScores = [];
  
  // Pobierz globalne wyniki z serwera
  try {
    const response = await fetch(`https://api.jsonbin.io/v3/b/${JSONBIN_BIN_ID}/latest`, {
      headers: {
        'X-Master-Key': JSONBIN_API_KEY
      }
    });
    
    if (response.ok) {
      const data = await response.json();
      globalScores = data.record[selectedSize] || [];
    }
  } catch (error) {
    console.error("B≈ÇƒÖd pobierania rankingu z serwera:", error);
  }
  
  // Pobierz lokalne wyniki
  const key = 'scores_' + selectedSize;
  localScores = JSON.parse(localStorage.getItem(key) || '[]');
  
  // Wy≈õwietl nag≈Ç√≥wek tabeli
  const headerRow = document.createElement('tr');
  headerRow.innerHTML = `
    <th>Nick</th>
    <th>Czas (s)</th>
  `;
  scoresEl.appendChild(headerRow);
  
  // Wy≈õwietl ranking globalny je≈õli sƒÖ wyniki
  if (globalScores.length > 0) {
    // Dodaj nag≈Ç√≥wek rankingu globalnego
    const globalHeader = document.createElement('tr');
    globalHeader.innerHTML = `
      <td colspan="2" class="ranking-header global-header">
        üåç Ranking Globalny (${globalScores.length} wynik√≥w)
      </td>
    `;
    scoresEl.appendChild(globalHeader);
    
    // Wy≈õwietl wyniki globalne
    globalScores.slice(0, 10).forEach((score, index) => {
      const row = document.createElement('tr');
      const medal = index === 0 ? 'ü•á' : index === 1 ? 'ü•à' : index === 2 ? 'ü•â' : 'üèÖ';
      row.innerHTML = `
        <td>${medal} ${score.nick}</td>
        <td>${score.time.toFixed(2)}</td>
      `;
      scoresEl.appendChild(row);
    });
    
    // Dodaj separator
    const separator = document.createElement('tr');
    separator.innerHTML = `
      <td colspan="2" class="ranking-divider">
        ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      </td>
    `;
    scoresEl.appendChild(separator);
  }
  
  // Wy≈õwietl ranking lokalny
  if (localScores.length > 0) {
    // Dodaj nag≈Ç√≥wek rankingu lokalnego
    const localHeader = document.createElement('tr');
    localHeader.innerHTML = `
      <td colspan="2" class="ranking-header local-header">
        üè† Ranking Lokalny (${localScores.length} wynik√≥w)
      </td>
    `;
    scoresEl.appendChild(localHeader);
    
    // Wy≈õwietl wyniki lokalne
    localScores.slice(0, 10).forEach((score, index) => {
      const row = document.createElement('tr');
      const medal = index === 0 ? 'ü•á' : index === 1 ? 'ü•à' : index === 2 ? 'ü•â' : 'üèÖ';
      row.innerHTML = `
        <td>${medal} ${score.nick}</td>
        <td>${score.time.toFixed(2)}</td>
      `;
      scoresEl.appendChild(row);
    });
  }
  
  // Je≈õli nie ma ≈ºadnych wynik√≥w
  if (globalScores.length === 0 && localScores.length === 0) {
    const noScoresRow = document.createElement('tr');
    noScoresRow.innerHTML = `
      <td colspan="2" style="text-align:center;padding:20px;color:#666;font-style:italic;">
        Brak wynik√≥w dla tego rozmiaru.<br>Zagraj w grƒô aby pojawi≈Çy siƒô tutaj!
      </td>
    `;
    scoresEl.appendChild(noScoresRow);
  }
}

function rand(n){
  return Math.floor(Math.random() * n);
}

// Inicjalizacja
renderScores();
updateHardestWordDisplay();
</script>
</body>
</html>