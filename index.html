<!doctype html>
<html lang="pl">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="wykre≈õlanka">
    <title>made by piotrek ‚ù§Ô∏è</title>
    
    <style>
    /* =============== VARIABLES & THEME =============== */
    :root {
        --bg: #f6f7fb;
        --card: #fff;
        --text: #111;
        --cell: #eef2ff;
        --cell-sel: #b6ccff;
        --cell-found: #9fe6a0;
        --tile: 46px;
        --primary: #4f7cff;
        --secondary: #777;
        --danger: #ff6b6b;
        --success: #4CAF50;
        --warning: #FF9800;
    }
    
    body.dark {
        --bg: #0f1220;
        --card: #1a1e35;
        --text: #f2f4ff;
        --cell: #2a2f55;
        --cell-sel: #3c4aa8;
        --cell-found: #2f8f5b;
    }
    
    /* =============== BASE STYLES =============== */
    * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
        -webkit-tap-highlight-color: transparent;
    }
    
    body {
        font-family: system-ui, -apple-system, sans-serif;
        background: var(--bg);
        color: var(--text);
        padding: 20px;
        transition: background-color 0.3s, color 0.3s;
        line-height: 1.6;
    }
    
    h1 {
        font-size: 2.2rem;
        margin-bottom: 20px;
        text-align: center;
        color: var(--primary);
    }
    
    h3 {
        font-size: 1.4rem;
        margin-bottom: 15px;
        color: var(--text);
    }
    
    h4 {
        font-size: 1.1rem;
        margin-bottom: 10px;
        color: var(--text);
    }
    
    /* =============== LAYOUT =============== */
    .layout {
        display: grid;
        grid-template-columns: 1fr 2fr 1fr;
        gap: 20px;
        margin-top: 20px;
    }
    
    .card {
        background: var(--card);
        border-radius: 16px;
        padding: 20px;
        box-shadow: 0 10px 25px rgba(0, 0, 0, 0.15);
        transition: transform 0.2s, box-shadow 0.2s;
    }
    
    .card:hover {
        transform: translateY(-2px);
        box-shadow: 0 15px 30px rgba(0, 0, 0, 0.2);
    }
    
    /* =============== CONTROLS =============== */
    .controls {
        display: flex;
        gap: 12px;
        flex-wrap: wrap;
        margin-bottom: 20px;
        align-items: center;
    }
    
    button, input, select {
        padding: 12px 16px;
        border-radius: 12px;
        border: 2px solid transparent;
        font-size: 1rem;
        transition: all 0.2s;
    }
    
    input, select {
        background: var(--card);
        color: var(--text);
        border-color: var(--cell);
        flex: 1;
        min-width: 120px;
    }
    
    input:focus, select:focus {
        outline: none;
        border-color: var(--primary);
        box-shadow: 0 0 0 3px rgba(79, 124, 255, 0.1);
    }
    
    button {
        background: var(--primary);
        color: white;
        border: none;
        cursor: pointer;
        font-weight: 600;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        gap: 8px;
    }
    
    button:hover:not(:disabled) {
        background: #3a6bff;
        transform: translateY(-1px);
    }
    
    button:active:not(:disabled) {
        transform: translateY(0);
    }
    
    button.secondary {
        background: var(--secondary);
    }
    
    button.secondary:hover:not(:disabled) {
        background: #666;
    }
    
    button.danger {
        background: var(--danger);
    }
    
    button.danger:hover:not(:disabled) {
        background: #ff5252;
    }
    
    button.hidden {
        display: none;
    }
    
    button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
        transform: none !important;
    }
    
    /* =============== GAME BOARD =============== */
    .board {
        display: grid;
        gap: 8px;
        justify-content: center;
        min-height: 300px;
        margin: 20px 0;
    }
    
    .cell {
        width: var(--tile);
        height: var(--tile);
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: 700;
        font-size: 1.1rem;
        border-radius: 10px;
        background: var(--cell);
        user-select: none;
        cursor: pointer;
        transition: all 0.2s;
        opacity: 0;
        position: relative;
        overflow: hidden;
    }
    
    .cell::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: linear-gradient(135deg, rgba(255,255,255,0.1) 0%, rgba(255,255,255,0) 100%);
        border-radius: 10px;
    }
    
    .cell.show {
        opacity: 1;
    }
    
    .cell.sel {
        background: var(--cell-sel);
        transform: scale(1.05);
        z-index: 1;
    }
    
    .cell.found {
        background: var(--cell-found);
        animation: foundPop 0.3s ease;
    }
    
    .cell.morph {
        animation: morph 0.4s ease forwards;
    }
    
    .cell.pulse {
        animation: pulse 1s infinite;
    }
    
    /* =============== ANIMATIONS =============== */
    @keyframes morph {
        0% { transform: scale(0.7); filter: hue-rotate(0deg); opacity: 0; }
        50% { transform: scale(1.15); filter: hue-rotate(180deg); opacity: 1; }
        100% { transform: scale(1); filter: hue-rotate(360deg); opacity: 1; }
    }
    
    @keyframes pulse {
        0% { transform: scale(1); }
        50% { transform: scale(1.1); }
        100% { transform: scale(1); }
    }
    
    @keyframes foundPop {
        0% { transform: scale(1); }
        50% { transform: scale(1.2); }
        100% { transform: scale(1); }
    }
    
    /* =============== STATUS & MESSAGES =============== */
    #status {
        text-align: center;
        font-size: 1.2rem;
        margin: 20px 0;
        min-height: 40px;
        display: flex;
        align-items: center;
        justify-content: center;
        color: var(--text);
    }
    
    .record-message {
        background: linear-gradient(45deg, var(--danger), var(--success), var(--primary));
        background-size: 300% 300%;
        color: white;
        padding: 20px 30px;
        border-radius: 15px;
        font-weight: bold;
        font-size: 1.3rem;
        text-align: center;
        margin: 20px auto;
        animation: rainbow 2s infinite, floatMessage 4s ease-in-out infinite;
        display: none;
        max-width: 90%;
        box-shadow: 0 10px 20px rgba(0,0,0,0.2);
        z-index: 1002;
        position: relative;
    }
    
    .cooldown-timer {
        color: var(--danger);
        font-weight: bold;
        font-size: 1rem;
        margin-top: 10px;
        text-align: center;
        display: none;
        padding: 10px;
        background: rgba(255, 107, 107, 0.1);
        border-radius: 10px;
    }
    
    /* =============== RULES & STATS =============== */
    ul {
        padding-left: 20px;
        margin-bottom: 20px;
    }
    
    li {
        margin-bottom: 8px;
        color: var(--text);
    }
    
    #hardestWord {
        margin-top: 25px;
        padding-top: 20px;
        border-top: 2px solid var(--cell);
    }
    
    #hardestWordDisplay {
        font-size: 1.2rem;
        font-weight: bold;
        color: var(--danger);
        margin-top: 15px;
        text-align: center;
    }
    
    /* =============== RANKING =============== */
    .table {
        overflow: hidden;
    }
    
    .table table {
        width: 100%;
        border-collapse: collapse;
        margin-top: 10px;
    }
    
    .table th, .table td {
        padding: 12px 8px;
        text-align: left;
        border-bottom: 1px solid var(--cell);
    }
    
    .table th {
        background: rgba(79, 124, 255, 0.1);
        font-weight: 600;
        color: var(--primary);
    }
    
    .table tr:hover {
        background: rgba(79, 124, 255, 0.05);
    }
    
    .ranking-header {
        text-align: center;
        font-weight: bold;
        padding: 12px;
        border-radius: 10px;
        margin: 15px 0;
        font-size: 1rem;
        letter-spacing: 0.5px;
    }
    
    .global-header {
        background: linear-gradient(45deg, var(--success), #45a049);
        color: white;
    }
    
    .local-header {
        background: linear-gradient(45deg, var(--warning), #f57c00);
        color: white;
    }
    
    .ranking-divider {
        height: 20px;
        text-align: center;
        color: var(--secondary);
        font-size: 0.9rem;
        padding: 10px;
        opacity: 0.7;
    }
    
    .ranking-container {
        max-height: 500px;
        overflow-y: auto;
        padding-right: 5px;
        margin-top: 10px;
    }
    
    /* Scrollbar styling */
    .ranking-container::-webkit-scrollbar {
        width: 8px;
    }
    
    .ranking-container::-webkit-scrollbar-track {
        background: var(--cell);
        border-radius: 4px;
    }
    
    .ranking-container::-webkit-scrollbar-thumb {
        background: var(--primary);
        border-radius: 4px;
    }
    
    .ranking-container::-webkit-scrollbar-thumb:hover {
        background: #3a6bff;
    }
    
    /* =============== CELEBRATION ANIMATIONS =============== */
    .celebration {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        z-index: 1000;
        display: none;
        overflow: hidden;
    }
    
    .cat-emoji {
        position: absolute;
        font-size: 2.5rem;
        animation: catFloat 5s linear forwards;
        opacity: 1;
        filter: drop-shadow(0 5px 15px rgba(0,0,0,0.3));
        pointer-events: none;
        z-index: 1001;
    }
    
    @keyframes catFloat {
        0% {
            transform: translateY(100vh) rotate(0deg) scale(0.8);
            opacity: 1;
        }
        10% {
            opacity: 1;
            transform: translateY(80vh) rotate(90deg) scale(1);
        }
        90% {
            opacity: 1;
        }
        100% {
            transform: translateY(-100px) rotate(360deg) scale(1.2);
            opacity: 0;
        }
    }
    
    @keyframes floatMessage {
        0% {
            transform: translateY(0px) translateX(0px);
        }
        25% {
            transform: translateY(-15px) translateX(10px);
        }
        50% {
            transform: translateY(5px) translateX(-10px);
        }
        75% {
            transform: translateY(-10px) translateX(5px);
        }
        100% {
            transform: translateY(0px) translateX(0px);
        }
    }
    
    @keyframes rainbow {
        0% { background-position: 0% 50%; }
        50% { background-position: 100% 50%; }
        100% { background-position: 0% 50%; }
    }
    
    /* =============== RESPONSIVE DESIGN =============== */
    @media (max-width: 1100px) {
        .layout {
            grid-template-columns: 1fr 1.5fr;
        }
        
        .layout > .card:last-child {
            grid-column: 1 / -1;
        }
    }
    
    @media (max-width: 768px) {
        .layout {
            grid-template-columns: 1fr;
            gap: 15px;
        }
        
        body {
            padding: 15px;
        }
        
        h1 {
            font-size: 1.8rem;
        }
        
        h3 {
            font-size: 1.3rem;
        }
        
        .card {
            padding: 15px;
        }
        
        .controls {
            flex-direction: column;
            align-items: stretch;
        }
        
        .controls > * {
            width: 100%;
            margin-bottom: 10px;
        }
        
        :root {
            --tile: 42px;
        }
        
        .cell {
            font-size: 1rem;
        }
        
        .record-message {
            font-size: 1.1rem;
            padding: 15px 20px;
        }
        
        .cat-emoji {
            font-size: 2rem;
        }
    }
    
    @media (max-width: 480px) {
        :root {
            --tile: 38px;
        }
        
        body {
            padding: 10px;
        }
        
        .card {
            padding: 12px;
        }
        
        h1 {
            font-size: 1.6rem;
        }
        
        h3 {
            font-size: 1.2rem;
        }
        
        .cell {
            font-size: 0.95rem;
        }
        
        button, input, select {
            padding: 10px 14px;
            font-size: 0.95rem;
        }
        
        .table th, .table td {
            padding: 10px 6px;
            font-size: 0.9rem;
        }
    }
    
    @media (max-width: 360px) {
        :root {
            --tile: 34px;
        }
        
        .cell {
            font-size: 0.9rem;
        }
        
        .table th, .table td {
            font-size: 0.85rem;
            padding: 8px 4px;
        }
    }
    
    /* =============== UTILITY CLASSES =============== */
    .text-center {
        text-align: center;
    }
    
    .mt-10 {
        margin-top: 10px;
    }
    
    .mt-20 {
        margin-top: 20px;
    }
    
    .mb-10 {
        margin-bottom: 10px;
    }
    
    .mb-20 {
        margin-bottom: 20px;
    }
    
    /* =============== ACCESSIBILITY =============== */
    @media (prefers-reduced-motion: reduce) {
        * {
            animation-duration: 0.01ms !important;
            animation-iteration-count: 1 !important;
            transition-duration: 0.01ms !important;
        }
    }
    
    .sr-only {
        position: absolute;
        width: 1px;
        height: 1px;
        padding: 0;
        margin: -1px;
        overflow: hidden;
        clip: rect(0, 0, 0, 0);
        white-space: nowrap;
        border: 0;
    }
    </style>
</head>

<body>
    <!-- HEADER -->
    <header class="text-center">
        <h1>s≈Çona gierka</h1>
        <p style="color: var(--secondary); margin-bottom: 20px;">Znajd≈∫ ukryte s≈Çowa</p>
    </header>

    <!-- CONTROLS -->
    <div class="card controls">
        <input id="nick" placeholder="Tw√≥j nick" aria-label="Tw√≥j nick">
        <select id="level" aria-label="Wybierz poziom trudno≈õci">
            <option value="7">7√ó7 (≈Åatwy)</option>
            <option value="12">12√ó12 (≈öredni)</option>
            <option value="15">15√ó15 (Trudny)</option>
        </select>
        <button id="start" aria-label="Rozpocznij grƒô">‚ñ∂Ô∏è Rozpocznij</button>
        <button id="giveup" class="secondary hidden" aria-label="Poddaj siƒô">üè≥Ô∏è Poddaj siƒô</button>
        <button id="theme" class="secondary" aria-label="Prze≈ÇƒÖcz motyw">üåô</button>
        <div id="cooldownTimer" class="cooldown-timer" role="timer" aria-live="polite"></div>
    </div>

    <!-- MAIN LAYOUT -->
    <div class="layout">
        <!-- LEFT PANEL: RULES & STATS -->
        <div class="card">
            <h3>üìú Zasady gry</h3>
            <ul>
                <li>Znajd≈∫ ukryte nazwisko na planszy</li>
                <li>Mo≈ºesz zaznaczaƒá w poziomie, pionie lub na skos</li>
                <li>S≈Çowo mo≈ºe byƒá u≈Ço≈ºone r√≥wnie≈º wspak</li>
                <li>Im szybciej znajdziesz, tym lepszy wynik!</li>
            </ul>
            
            <div id="hardestWord" class="mt-20">
                <h4>üåç Statystyki globalne</h4>
                <div id="hardestWordDisplay" class="mt-10">
                    <div style="color: var(--secondary); font-style: italic;">≈Åadowanie statystyk...</div>
                </div>
            </div>
        </div>

        <!-- CENTER PANEL: GAME BOARD -->
        <div class="card">
            <div id="board" class="board" role="grid" aria-label="Plansza gry"></div>
            <div id="status" role="status" aria-live="polite">Wybierz nick i rozpocznij grƒô!</div>
            <div id="recordMessage" class="record-message" role="alert" aria-live="assertive"></div>
        </div>

        <!-- RIGHT PANEL: RANKING -->
        <div class="card table">
            <h3>üèÜ Ranking <span id="lvlLabel" class="badge">7√ó7</span></h3>
            <div class="ranking-container">
                <table id="scores" aria-label="Tabela rankingowa">
                    <thead>
                        <tr>
                            <th scope="col">Miejsce</th>
                            <th scope="col">Nick</th>
                            <th scope="col">Czas (s)</th>
                        </tr>
                    </thead>
                    <tbody>
                        <!-- Dynamicznie wype≈Çniane przez JS -->
                    </tbody>
                </table>
            </div>
        </div>
    </div>

    <!-- CELEBRATION ANIMATION -->
    <div id="celebration" class="celebration" aria-hidden="true"></div>

    <!-- FOOTER -->
    <footer class="text-center mt-20" style="color: var(--secondary); font-size: 0.9rem;">
        <p>made by piotrek ‚ù§Ô∏è</p>
    </footer>

    <script>
    // =============== GLOBAL VARIABLES ===============
    'use strict';

    const WORDS = [
        "KOBYLNIK", "RENZ", "≈öLƒÑSKA", "≈ÅATA", "ƒÜWIK", "GRYSA", "MATYSIAK", 
        "SZCZEPANIAK", "KABACI≈ÉSKA", "GƒÑGA≈ÅA", "GRAL", "KOWALCZYK", "ORWAT", 
        "AUGUSTYNIAK", "WASILEWSKI", "GELLERT", "BADOWSKA", "BALCEREK", 
        "RATAJCZAK", "GNI≈ÅKA", "TOMCZAK", "SIEK", "SZARZEWSKI", "KOPYCHYN", "O≈ªA≈ÉSKA"
    ];
    
    const LETTERS = "AƒÑBCƒÜDEƒòFGHIJKL≈ÅMN≈ÉO√ìPRS≈öTUVWXYZ≈π≈ª";
    const CAT_EMOJIS = ["üò∫", "üò∏", "üòπ", "üòª", "üòº", "üòΩ", "üôÄ", "üòø", "üòæ", "üê±"];
    
    // JSONBin.io configuration
    const JSONBIN_BIN_ID = "697bcee243b1c97be955c919";
    const JSONBIN_STATS_BIN_ID = "697bd2b6d0ea881f40913cce";
    const JSONBIN_API_KEY = "$2a$10$Poka03qXK.rnNNTaGYW/zOLzQlBUuKiGlPxjSxYaKCKc1AV6c04We";
    
    // DOM Elements
    const boardEl = document.getElementById('board');
    const statusEl = document.getElementById('status');
    const scoresEl = document.getElementById('scores').getElementsByTagName('tbody')[0];
    const startBtn = document.getElementById('start');
    const giveupBtn = document.getElementById('giveup');
    const levelEl = document.getElementById('level');
    const lvlLabel = document.getElementById('lvlLabel');
    const nickInput = document.getElementById('nick');
    const themeBtn = document.getElementById('theme');
    const celebrationEl = document.getElementById('celebration');
    const recordMessageEl = document.getElementById('recordMessage');
    const hardestWordDisplay = document.getElementById('hardestWordDisplay');
    const cooldownTimerEl = document.getElementById('cooldownTimer');
    
    // Game state
    let grid = [], size = 7, target = "", path = [], selecting = false, startTime = 0;
    let solution = [];
    let gameActive = false;
    let currentDirection = null;
    let isGameStarting = false;
    let giveupCooldown = 0;
    let cooldownInterval = null;
    let isMouseDown = false;
    let isMobile = false;
    let lastTouchEnd = 0;
    
    // =============== UTILITY FUNCTIONS ===============
    function rand(n) {
        return Math.floor(Math.random() * n);
    }
    
    function formatTime(seconds) {
        return seconds.toFixed(2);
    }
    
    function getMedalEmoji(index) {
        switch(index) {
            case 0: return 'ü•á';
            case 1: return 'ü•à';
            case 2: return 'ü•â';
            default: return `${index + 1}.`;
        }
    }
    
    // =============== MOBILE DETECTION & HANDLING ===============
    function checkIfMobile() {
        isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || 
                  (window.innerWidth <= 768);
        if (isMobile) {
            document.body.classList.add('mobile');
        }
        return isMobile;
    }
    
    function preventDoubleTapZoom(e) {
        const now = Date.now();
        if (now - lastTouchEnd <= 300) {
            e.preventDefault();
        }
        lastTouchEnd = now;
    }
    
    function adjustBoardForMobile() {
        if (!isMobile) return;
        
        const viewportWidth = window.innerWidth;
        let tileSize;
        
        if (viewportWidth < 400) tileSize = 32;
        else if (viewportWidth < 600) tileSize = 36;
        else if (viewportWidth < 768) tileSize = 40;
        else tileSize = 46;
        
        document.documentElement.style.setProperty('--tile', `${tileSize}px`);
    }
    
    // =============== THEME MANAGEMENT ===============
    function initTheme() {
        const savedTheme = localStorage.getItem('theme') || 'light';
        if (savedTheme === 'dark') {
            document.body.classList.add('dark');
            themeBtn.textContent = '‚òÄÔ∏è';
        } else {
            themeBtn.textContent = 'üåô';
        }
        
        themeBtn.addEventListener('click', toggleTheme);
    }
    
    function toggleTheme() {
        const isDark = document.body.classList.toggle('dark');
        localStorage.setItem('theme', isDark ? 'dark' : 'light');
        themeBtn.textContent = isDark ? '‚òÄÔ∏è' : 'üåô';
        themeBtn.setAttribute('aria-label', isDark ? 'Prze≈ÇƒÖcz na jasny motyw' : 'Prze≈ÇƒÖcz na ciemny motyw');
    }
    
    // =============== GAME INITIALIZATION ===============
    function initGame() {
        checkIfMobile();
        initTheme();
        initEventListeners();
        renderScores();
        updateStatsDisplay();
        
        // Preload animation
        window.addEventListener('load', () => {
            const style = document.createElement('style');
            style.textContent = `.preload-animation { animation: morph .4s ease; }`;
            document.head.appendChild(style);
            setTimeout(() => document.head.removeChild(style), 100);
        });
    }
    
    function initEventListeners() {
        startBtn.addEventListener('click', startGame);
        giveupBtn.addEventListener('click', giveUpGame);
        levelEl.addEventListener('change', renderScores);
        
        // Mobile touch events
        if (isMobile) {
            document.addEventListener('touchstart', (e) => {
                if (e.touches.length > 1) e.preventDefault();
            }, { passive: false });
            
            document.addEventListener('touchend', preventDoubleTapZoom, false);
        } else {
            document.addEventListener('mousedown', () => {
                if (gameActive) isMouseDown = true;
            });
            
            document.addEventListener('mouseup', () => {
                if (gameActive && isMouseDown) {
                    isMouseDown = false;
                    if (selecting) endSelection();
                }
            });
        }
        
        // Responsive adjustments
        window.addEventListener('resize', () => {
            checkIfMobile();
            adjustBoardForMobile();
        });
        
        window.addEventListener('orientationchange', () => {
            setTimeout(() => {
                adjustBoardForMobile();
                if (boardEl.children.length > 0) recalculateBoard();
            }, 300);
        });
    }
    
    // =============== GAME LOGIC ===============
    function startGame() {
        if (isGameStarting) return;
        isGameStarting = true;
        
        const nick = nickInput.value.trim();
        if (!nick) {
            alert("Proszƒô podaƒá nick przed rozpoczƒôciem gry!");
            isGameStarting = false;
            return;
        }
        
        // Sprawd≈∫ czy to specjalny nick
        if (nick =scal"randka") {
            window.location.href = "randka";
            return;
        }
        
        if (isMobile && document.activeElement === nickInput) {
            nickInput.blur();
        }
        
        // Setup game
        size = parseInt(levelEl.value);
        lvlLabel.textContent = `${size}√ó${size}`;
        
        startBtn.classList.add('hidden');
        giveupBtn.classList.remove('hidden');
        gameActive = true;
        currentDirection = null;
        recordMessageEl.style.display = 'none';
        
        // Setup cooldown
        setupGiveupCooldown();
        
        // Prepare and draw board
        prepareNewGrid();
        boardEl.innerHTML = '';
        draw();
        
        setTimeout(() => {
            animateBoardStart();
            startTime = Date.now();
            statusEl.textContent = "Znajd≈∫ ukryte s≈Çowo!";
            if (isMobile) {
                setTimeout(() => {
                    statusEl.innerHTML = "Znajd≈∫ ukryte s≈Çowo!<br><small style='color:var(--secondary)'>PrzeciƒÖgnij palcem aby zaznaczyƒá</small>";
                }, 1500);
            }
            isGameStarting = false;
        }, isMobile ? 100 : 50);
    }
    
    function setupGiveupCooldown() {
        giveupCooldown = 5;
        giveupBtn.disabled = true;
        giveupBtn.textContent = `Poddaj siƒô (${giveupCooldown}s)`;
        cooldownTimerEl.style.display = 'block';
        cooldownTimerEl.textContent = `Mo≈ºesz siƒô poddaƒá za: ${giveupCooldown}s`;
        
        if (cooldownInterval) clearInterval(cooldownInterval);
        
        cooldownInterval = setInterval(() => {
            giveupCooldown--;
            giveupBtn.textContent = `Poddaj siƒô (${giveupCooldown}s)`;
            cooldownTimerEl.textContent = `Mo≈ºesz siƒô poddaƒá za: ${giveupCooldown}s`;
            
            if (giveupCooldown <= 0) {
                clearInterval(cooldownInterval);
                cooldownInterval = null;
                giveupBtn.disabled = false;
                giveupBtn.textContent = "üè≥Ô∏è Poddaj siƒô";
                cooldownTimerEl.style.display = 'none';
            }
        }, 1000);
    }
    
    function prepareNewGrid() {
        grid = Array.from({ length: size }, () => Array(size).fill(''));
        
        let placed = false;
        let attempts = 0;
        const maxAttempts = 50;
        
        while (!placed && attempts < maxAttempts) {
            target = WORDS[rand(WORDS.length)];
            
            if (target.length > size) {
                attempts++;
                continue;
            }
            
            solution = [];
            placed = placeWord();
            attempts++;
        }
        
        if (!placed) {
            const shortWords = WORDS.filter(word => word.length <= size);
            target = shortWords.length > 0 ? shortWords[rand(shortWords.length)] : WORDS[0].substring(0, size);
            solution = [];
            placeWord();
        }
        
        fillGrid();
    }
    
    function placeWord() {
        const directions = [[1,0], [0,1], [1,1], [-1,0], [0,-1], [-1,-1], [1,-1], [-1,1]];
        const [dx, dy] = directions[rand(directions.length)];
        const word = Math.random() < 0.5 ? target : [...target].reverse().join('');
        
        let maxR, maxC, minR, minC;
        
        if (dy > 0) {
            minR = 0;
            maxR = size - word.length;
        } else if (dy < 0) {
            minR = word.length - 1;
            maxR = size - 1;
        } else {
            minR = 0;
            maxR = size - 1;
        }
        
        if (dx > 0) {
            minC = 0;
            maxC = size - word.length;
        } else if (dx < 0) {
            minC = word.length - 1;
            maxC = size - 1;
        } else {
            minC = 0;
            maxC = size - 1;
        }
        
        if (minR > maxR || minC > maxC) return false;
        
        const r = minR + rand(maxR - minR + 1);
        const c = minC + rand(maxC - minC + 1);
        
        for (let i = 0; i < word.length; i++) {
            const rr = r + dy * i;
            const cc = c + dx * i;
            
            if (rr >= 0 && rr < size && cc >= 0 && cc < size) {
                grid[rr][cc] = word[i];
                solution.push([rr, cc]);
            } else {
                return false;
            }
        }
        return true;
    }
    
    function fillGrid() {
        for (let r = 0; r < size; r++) {
            for (let c = 0; c < size; c++) {
                if (!grid[r][c]) {
                    grid[r][c] = LETTERS[rand(LETTERS.length)];
                }
            }
        }
    }
    
    function draw() {
        boardEl.style.gridTemplateColumns = `repeat(${size}, var(--tile))`;
        boardEl.innerHTML = '';
        
        for (let r = 0; r < size; r++) {
            for (let c = 0; c < size; c++) {
                const cell = document.createElement('div');
                cell.className = 'cell';
                cell.dataset.r = r;
                cell.dataset.c = c;
                cell.textContent = grid[r][c];
                cell.setAttribute('role', 'gridcell');
                cell.setAttribute('aria-label', `Kom√≥rka ${r + 1},${c + 1}: ${grid[r][c]}`);
                
                if (isMobile) {
                    cell.addEventListener('touchstart', handleTouchStart, { passive: false });
                    cell.addEventListener('touchmove', handleTouchMove, { passive: false });
                    cell.addEventListener('touchend', handleTouchEnd);
                } else {
                    cell.addEventListener('mousedown', handleMouseDown);
                    cell.addEventListener('mouseenter', handleMouseEnter);
                    cell.addEventListener('mouseup', handleMouseUp);
                }
                
                boardEl.appendChild(cell);
            }
        }
        
        if (isMobile) {
            document.addEventListener('touchend', handleGlobalTouchEnd);
        }
    }
    
    function animateBoardStart() {
        const cells = boardEl.children;
        if (cells.length === 0) return;
        
        const step = isMobile ? 60 : 40;
        const centerX = Math.floor(size / 2);
        const centerY = Math.floor(size / 2);
        
        Array.from(cells).forEach(cell => {
            const r = parseInt(cell.dataset.r);
            const c = parseInt(cell.dataset.c);
            const distance = Math.sqrt(Math.pow(r - centerY, 2) + Math.pow(c - centerX, 2));
            const delay = distance * step;
            
            setTimeout(() => {
                cell.classList.add('morph', 'show');
                
                setTimeout(() => {
                    cell.classList.remove('morph');
                }, 500);
            }, delay);
        });
    }
    
    // =============== INPUT HANDLING ===============
    let touchStartCell = null;
    
    function handleTouchStart(e) {
        if (!gameActive || this.classList.contains('found')) return;
        e.preventDefault();
        selecting = true;
        touchStartCell = this;
        path = [this];
        currentDirection = null;
        this.classList.add('sel');
    }
    
    function handleTouchMove(e) {
        if (!selecting || !gameActive) return;
        e.preventDefault();
        
        const touch = e.touches[0];
        const element = document.elementFromPoint(touch.clientX, touch.clientY);
        
        if (element && element.classList.contains('cell') && !element.classList.contains('found')) {
            processCellSelection(element);
        }
    }
    
    function handleTouchEnd() {
        if (!selecting || !gameActive) return;
        selecting = false;
        checkWordSelection();
    }
    
    function handleGlobalTouchEnd() {
        if (selecting) handleTouchEnd();
    }
    
    function handleMouseDown(e) {
        if (!gameActive || this.classList.contains('found')) return;
        e.preventDefault();
        selecting = true;
        isMouseDown = true;
        path = [this];
        currentDirection = null;
        this.classList.add('sel');
    }
    
    function handleMouseEnter() {
        if (!isMouseDown || !selecting || !gameActive || this.classList.contains('found')) return;
        processCellSelection(this);
    }
    
    function handleMouseUp() {
        if (!selecting || !gameActive) return;
        isMouseDown = false;
        endSelection();
    }
    
    function processCellSelection(cell) {
        if (path.includes(cell)) return;
        
        const last = path[path.length - 1];
        const dr = parseInt(cell.dataset.r) - parseInt(last.dataset.r);
        const dc = parseInt(cell.dataset.c) - parseInt(last.dataset.c);
        
        // Validate move
        if (Math.abs(dr) > 1 || Math.abs(dc) > 1) return;
        if (dr !== 0 && dc !== 0 && Math.abs(dr) !== Math.abs(dc)) return;
        
        // Check direction consistency
        if (path.length === 1) {
            if (dr === 0 && dc !== 0) currentDirection = 'horizontal';
            else if (dc === 0 && dr !== 0) currentDirection = 'vertical';
            else if (Math.abs(dr) === Math.abs(dc)) currentDirection = 'diagonal';
        } else {
            const [first, second] = [path[0], path[1]];
            const firstDr = parseInt(second.dataset.r) - parseInt(first.dataset.r);
            const firstDc = parseInt(second.dataset.c) - parseInt(first.dataset.c);
            
            if (firstDr === 0 && dr !== 0) return;
            if (firstDc === 0 && dc !== 0) return;
            if (firstDr !== 0 && firstDc !== 0) {
                if (Math.abs(dr) !== Math.abs(dc)) return;
                if (Math.sign(dr) !== Math.sign(firstDr) || Math.sign(dc) !== Math.sign(firstDc)) return;
            }
        }
        
        path.push(cell);
        cell.classList.add('sel');
    }
    
    function endSelection() {
        selecting = false;
        checkWordSelection();
    }
    
    function checkWordSelection() {
        const selectedWord = path.map(cell => cell.textContent).join('');
        const reversedWord = [...selectedWord].reverse().join('');
        
        if (selectedWord === target || reversedWord === target) {
            path.forEach(cell => {
                cell.classList.remove('sel');
                cell.classList.add('found');
            });
            finishGame();
        } else {
            // Visual feedback for wrong selection
            path.forEach(cell => {
                cell.classList.add('sel');
                setTimeout(() => cell.classList.remove('sel'), 300);
            });
        }
        
        path = [];
        currentDirection = null;
        touchStartCell = null;
    }
    
    function finishGame() {
        gameActive = false;
        isMouseDown = false;
        const time = ((Date.now() - startTime) / 1000).toFixed(2);
        
        statusEl.textContent = `üéâ Gratulacje! Znaleziono s≈Çowo "${target}" w ${time}s`;
        statusEl.setAttribute('aria-live', 'assertive');
        
        if (cooldownInterval) {
            clearInterval(cooldownInterval);
            cooldownInterval = null;
        }
        
        setTimeout(() => {
            addScore(nickInput.value.trim(), parseFloat(time));
        }, 0);
        
        startBtn.classList.remove('hidden');
        giveupBtn.classList.add('hidden');
    }
    
    function giveUpGame() {
        if (giveupCooldown > 0 || !gameActive) return;
        
        gameActive = false;
        isMouseDown = false;
        
        // Update global stats
        updateGlobalStats();
        updateStatsDisplay();
        
        // Reveal solution with animation
        const cells = Array.from(boardEl.children);
        solution.forEach(([r, c], index) => {
            setTimeout(() => {
                const cell = cells.find(e => 
                    parseInt(e.dataset.r) === r && parseInt(e.dataset.c) === c
                );
                if (cell) {
                    cell.classList.remove('sel');
                    cell.classList.add('found', 'pulse');
                }
            }, index * 100);
        });
        
        statusEl.textContent = `S≈Çowo to: ${target}`;
        
        if (cooldownInterval) {
            clearInterval(cooldownInterval);
            cooldownInterval = null;
        }
        
        startBtn.classList.remove('hidden');
        giveupBtn.classList.add('hidden');
    }
    
    // =============== STATISTICS MANAGEMENT ===============
    async function updateStatsDisplay() {
        try {
            const response = await fetch(`https://api.jsonbin.io/v3/b/${JSONBIN_STATS_BIN_ID}/latest`, {
                headers: { 'X-Master-Key': JSONBIN_API_KEY }
            });
            
            if (!response.ok) {
                throw new Error('Nie uda≈Ço siƒô pobraƒá statystyk');
            }
            
            const data = await response.json();
            const stats = data.record || {};
            
            // Znajd≈∫ s≈Çowo z najwiƒôkszƒÖ liczbƒÖ podda≈Ñ (najtrudniejsze)
            let hardestWord = '';
            let maxGiveup = -1;
            
            // Znajd≈∫ s≈Çowo z najmniejszƒÖ liczbƒÖ podda≈Ñ (naj≈Çatwiejsze/najczƒô≈õciej odgadywane)
            let easiestWord = '';
            let minGiveup = Infinity;
            
            // Sprawd≈∫ czy wszystkie s≈Çowa sƒÖ w stats
            WORDS.forEach(word => {
                const count = stats[word] || 0;
                
                if (count > maxGiveup) {
                    maxGiveup = count;
                    hardestWord = word;
                }
                
                if (count < minGiveup) {
                    minGiveup = count;
                    easiestWord = word;
                }
            });
            
            let statsHTML = '';
            
            if (hardestWord && maxGiveup >= 0) {
                statsHTML += `
                    <div style="margin-bottom: 15px;">
                        <div style="font-size: 0.9rem; color: var(--secondary);">Najtrudniejsze s≈Çowo (najczƒô≈õciej poddawane):</div>
                        <div style="font-size: 1.2rem; color: var(--danger); margin-top: 5px;">${hardestWord}</div>
                        </div>
                    </div>
                `;
            }
            
            if (easiestWord && minGiveup >= 0) {
                statsHTML += `
                    <div style="margin-top: 15px; padding-top: 15px; border-top: 1px dashed var(--cell);">
                        <div style="font-size: 0.9rem; color: var(--secondary);">Naj≈Çatwiejsze s≈Çowo (najrzadziej poddawane):</div>
                        <div style="font-size: 1.2rem; color: var(--success); margin-top: 5px;">${easiestWord}</div>
                        </div>
                    </div>
                `;
            }
            
            if (!statsHTML) {
                statsHTML = '<div style="color: var(--secondary); font-style: italic;">Brak statystyk.</div>';
            }
            
            hardestWordDisplay.innerHTML = statsHTML;
        } catch (error) {
            console.error("B≈ÇƒÖd pobierania statystyk globalnych:", error);
            hardestWordDisplay.innerHTML = '<div style="color: var(--secondary); font-style: italic;">B≈ÇƒÖd ≈Çadowania statystyk.</div>';
        }
    }
    
    async function updateGlobalStats() {
        try {
            const response = await fetch(`https://api.jsonbin.io/v3/b/${JSONBIN_STATS_BIN_ID}/latest`, {
                headers: { 'X-Master-Key': JSONBIN_API_KEY }
            });
            
            if (!response.ok) return;
            
            const data = await response.json();
            const globalStats = data.record || {};
            
            // Zwiƒôksz licznik dla aktualnego s≈Çowa
            globalStats[target] = (globalStats[target] || 0) + 1;
            
            // Upewnij siƒô, ≈ºe wszystkie s≈Çowa sƒÖ w stats
            WORDS.forEach(word => {
                if (globalStats[word] === undefined) {
                    globalStats[word] = 0;
                }
            });
            
            await fetch(`https://api.jsonbin.io/v3/b/${JSONBIN_STATS_BIN_ID}`, {
                method: 'PUT',
                headers: {
                    'X-Master-Key': JSONBIN_API_KEY,
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(globalStats)
            });
            
            // Od≈õwie≈º wy≈õwietlane statystyki
            updateStatsDisplay();
        } catch (error) {
            console.error("B≈ÇƒÖd zapisu statystyk globalnych:", error);
        }
    }
    
    // =============== SCORES & RANKING ===============
    async function addScore(nick, time) {
        const currentSize = size.toString();
        const key = `scores_${currentSize}`;
        let scores = JSON.parse(localStorage.getItem(key) || '[]');
        
        const normalizedNick = nick.toLowerCase().trim();
        
        // Znajd≈∫ najlepszy istniejƒÖcy wynik dla tego nicka (je≈õli istnieje)
        const existingScoresForNick = scores.filter(score => score.nick.toLowerCase().trim() === normalizedNick);
        const bestExistingTime = existingScoresForNick.length > 0 
            ? Math.min(...existingScoresForNick.map(s => s.time))
            : Infinity;
        
        // Je≈õli nowy wynik jest gorszy ni≈º najlepszy istniejƒÖcy, nie dodawaj go
        if (time > bestExistingTime) {
            console.log('Nowy wynik gorszy ni≈º najlepszy istniejƒÖcy dla tego nicka - pomijam');
            renderScores();
            return;
        }
        
        // Usu≈Ñ wszystkie wcze≈õniejsze wyniki dla tego nicka (dodamy tylko najlepszy)
        scores = scores.filter(score => score.nick.toLowerCase().trim() !== normalizedNick);
        
        const newScore = {
            nick: nick.trim(),
            time: time,
            date: new Date().toISOString()
        };
        
        scores.push(newScore);
        scores.sort((a, b) => a.time - b.time);
        const topScores = scores.slice(0, 10);
        localStorage.setItem(key, JSON.stringify(topScores));
        
        // Sprawd≈∫ czy to nowy rekord globalny
        let isNewGlobalRecord = false;
        
        try {
            const response = await fetch(`https://api.jsonbin.io/v3/b/${JSONBIN_BIN_ID}/latest`, {
                headers: { 'X-Master-Key': JSONBIN_API_KEY }
            });
            
            if (response.ok) {
                const data = await response.json();
                const allScores = data.record || { "7": [], "12": [], "15": [] };
                let globalScores = allScores[currentSize] || [];
                
                // Znajd≈∫ najlepszy istniejƒÖcy wynik dla tego nicka w rankingu globalnym
                const existingGlobalScoresForNick = globalScores.filter(
                    score => score.nick.toLowerCase().trim() === normalizedNick
                );
                const bestExistingGlobalTime = existingGlobalScoresForNick.length > 0
                    ? Math.min(...existingGlobalScoresForNick.map(s => s.time))
                    : Infinity;
                
                // Je≈õli nowy wynik jest lepszy ni≈º najlepszy istniejƒÖcy, zaktualizuj
                if (time < bestExistingGlobalTime) {
                    // Usu≈Ñ wszystkie wcze≈õniejsze wyniki dla tego nicka
                    globalScores = globalScores.filter(
                        score => score.nick.toLowerCase().trim() !== normalizedNick
                    );
                    
                    globalScores.push(newScore);
                    globalScores.sort((a, b) => a.time - b.time);
                    
                    // Zapisz 67 najlepszych wynik√≥w
                    allScores[currentSize] = globalScores.slice(0, 67);
                    
                    // Sprawd≈∫ czy to nowy rekord (pierwsze miejsce)
                    if (globalScores.length > 0 && globalScores[0].time === time) {
                        isNewGlobalRecord = true;
                    }
                    
                    await fetch(`https://api.jsonbin.io/v3/b/${JSONBIN_BIN_ID}`, {
                        method: 'PUT',
                        headers: {
                            'X-Master-Key': JSONBIN_API_KEY,
                            'Content-Type': 'application/json',
                            'X-Bin-Versioning': 'false'
                        },
                        body: JSON.stringify(allScores)
                    });
                }
            }
        } catch (error) {
            console.error("B≈ÇƒÖd synchronizacji z serwerem:", error);
        }
        
        renderScores();
        
        if (isNewGlobalRecord) {
            celebrateRecord(nick, time);
        }
    }
    
    async function renderScores() {
        const selectedSize = levelEl.value;
        lvlLabel.textContent = `${selectedSize}√ó${selectedSize}`;
        scoresEl.innerHTML = '';
        
        let globalScores = [];
        let localScores = [];
        
        // Get global scores (67 najlepszych)
        try {
            const response = await fetch(`https://api.jsonbin.io/v3/b/${JSONBIN_BIN_ID}/latest`, {
                headers: { 'X-Master-Key': JSONBIN_API_KEY }
            });
            
            if (response.ok) {
                const data = await response.json();
                const allScores = data.record || { "7": [], "12": [], "15": [] };
                globalScores = allScores[selectedSize] || [];
                // Sortuj i we≈∫ 67 najlepszych
                globalScores.sort((a, b) => a.time - b.time);
                globalScores = globalScores.slice(0, 67);
            }
        } catch (error) {
            console.error("B≈ÇƒÖd pobierania rankingu globalnego:", error);
        }
        
        // Get local scores (10 najlepszych)
        const key = `scores_${selectedSize}`;
        localScores = JSON.parse(localStorage.getItem(key) || '[]');
        
        // Display global ranking
        if (globalScores.length > 0) {
            const globalHeader = document.createElement('tr');
            globalHeader.innerHTML = `
                <td colspan="3" class="ranking-header global-header">
                    üåç Ranking Globalny (Top 67)
                </td>
            `;
            scoresEl.appendChild(globalHeader);
            
            globalScores.forEach((score, index) => {
                const row = document.createElement('tr');
                row.innerHTML = `
                    <td>${getMedalEmoji(index)}</td>
                    <td>${score.nick}</td>
                    <td>${formatTime(score.time)}</td>
                `;
                scoresEl.appendChild(row);
            });
            
            // Separator
            const separator = document.createElement('tr');
            separator.innerHTML = `<td colspan="3" class="ranking-divider">‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</td>`;
            scoresEl.appendChild(separator);
        }
        
        // Display local ranking
        if (localScores.length > 0) {
            const localHeader = document.createElement('tr');
            localHeader.innerHTML = `
                <td colspan="3" class="ranking-header local-header">
                    üè† Ranking Lokalny (Top 10)
                </td>
            `;
            scoresEl.appendChild(localHeader);
            
            localScores.forEach((score, index) => {
                const row = document.createElement('tr');
                row.innerHTML = `
                    <td>${getMedalEmoji(index)}</td>
                    <td>${score.nick}</td>
                    <td>${formatTime(score.time)}</td>
                `;
                scoresEl.appendChild(row);
            });
        }
        
        // No scores message
        if (globalScores.length === 0 && localScores.length === 0) {
            const noScoresRow = document.createElement('tr');
            noScoresRow.innerHTML = `
                <td colspan="3" style="text-align:center;padding:30px;color:var(--secondary);font-style:italic;">
                    Brak wynik√≥w dla tego rozmiaru.<br>
                    Zagraj w grƒô aby pojawi≈Çy siƒô tutaj!
                </td>
            `;
            scoresEl.appendChild(noScoresRow);
        }
    }
    
    // =============== CELEBRATIONS ===============
    function celebrateRecord(nick, time) {
        console.log('üéâ REKORD GLOBALNY!', nick, time);
        
        // 1. Poka≈º komunikat natychmiast
        recordMessageEl.textContent = `üèÜ ${nick} ustanowi≈Çe≈õ REKORD GLOBALNY! ${time}s üèÜ`;
        recordMessageEl.style.display = 'block';
        
        // 2. Stw√≥rz konfetti z kotkami NATYCHMIAST
        celebrationEl.innerHTML = '';
        celebrationEl.style.display = 'block';
        
        const emojiCount = 80; // Wiƒôcej kotk√≥w
        
        for(let i = 0; i < emojiCount; i++) {
            const emoji = document.createElement('div');
            emoji.textContent = CAT_EMOJIS[Math.floor(Math.random() * CAT_EMOJIS.length)];
            emoji.className = 'cat-emoji';
            emoji.style.left = Math.random() * 100 + 'vw';
            emoji.style.fontSize = (1.5 + Math.random() * 2) + 'rem';
            emoji.style.animationDelay = (Math.random() * 0.5) + 's'; // Mniejsze op√≥≈∫nienie
            emoji.style.animationDuration = '5s'; // Sta≈Çe 5 sekund
            
            celebrationEl.appendChild(emoji);
        }
        
        // 3. Ukryj po 5 sekundach
        setTimeout(() => {
            celebrationEl.style.display = 'none';
            recordMessageEl.style.display = 'none';
        }, 5000); // 5 sekund
    }
    
    // =============== HELPER FUNCTIONS ===============
    function recalculateBoard() {
        // Recalculate board dimensions if needed
    }
    
    // =============== INITIALIZATION ===============
    document.addEventListener('DOMContentLoaded', initGame);
    </script>
</body>
</html>
